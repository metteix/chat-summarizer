from typing import List, Any, Literal
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field


# --- Модели ответа ---
class ItemAnalysis(BaseModel):
    id: int = Field(description="ID объекта из базы")
    is_important: bool = Field(description="True, если это важно для учебы/работы. False, если спам/оффтоп.")
    about: str = Field(
        description="Краткая выжимка на русском. Для ссылок - заголовок, для задач - действие + дедлайн(если указан), для хештегов - важные хештеги, для упоминаний - важные упоминания, для документов - заголовки.")


class BatchAnalysis(BaseModel):
    items: List[ItemAnalysis]


# --- Настройка ---
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
structured_llm = llm.with_structured_output(BatchAnalysis)

# --- УНИКАЛЬНЫЕ ИНСТРУКЦИИ (ПРОМПТЫ) ---
PROMPTS = {
    "link": """
    Ты помощник студента. Твоя задача — отфильтровать список ССЫЛОК из чата.

    Критерии ВАЖНОСТИ (is_important = True):
    1. Ссылки на учебные ресурсы (GitHub, StackOverflow, Moodle, Википедия, Google Docs).
    2. Ссылки на YouTube, если в контексте понятно, что это лекция или туториал.
    3. Любые ссылки, если пользователь пишет "посмотрите", "важно", "для экзамена".

    Критерии МУСОРА (is_important = False):
    1. TikTok, Instagram, развлекательный контент (если это не учебный пример).
    2. Ссылки без контекста, похожие на спам или рекламу.

    Поле 'about': Напиши ЗАГОЛОВОК ресурса, исходя из URL и комментария пользователя.
    ОГРАНИЧЕНИЕ: Максимум 10 слов (до 70 символов).
    Пример: "Лекция по Алгосам (YouTube)"
    """,

    "doc": """
    Ты помощник студента. Твоя задача — отфильтровать ДОКУМЕНТЫ (файлы).

    Критерии ВАЖНОСТИ:
    1. Форматы .pdf, .docx, .pptx, .xlsx, .py, .zip (обычно это учебные материалы).
    2. Если имя файла осмысленное (lab1.pdf, lecture.pptx).
    3. Картинки (.jpg, .png) важны ТОЛЬКО если контекст говорит "вот скрин задания" или "расписание".

    Критерии МУСОРА:
    1. Стикеры, мемы (обычно странные названия или контекст "лол").

    Поле 'about': Объедини имя файла и контекст.
    ОГРАНИЧЕНИЕ: Максимум 10 слов.
    Пример: "Презентация к лекции 5"
    """,

    "task": """
    Ты помощник студента. Твоя задача — найти реальные ЗАДАЧИ и ДЕДЛАЙНЫ.

    Критерии ВАЖНОСТИ:
    1. Сообщения, где кого-то просят что-то сделать.
    2. Упоминания сроков (завтра, до среды, в 12:00).
    3. Организационная инфа (сбор денег, перенос пары).

    Критерии МУСОРА:
    1. Риторические вопросы ("когда же я сдохну?").
    2. Обсуждение личных проблем ("надо бы поспать").

    Поле 'about': Четко сформулируй задачу. Если есть дата/время — обязательно укажи.
    ОГРАНИЧЕНИЕ: Максимум 12 слов.
    Пример: "Сдать лабу до вторника (12:00)"
    """,

    "hashtag": """
    Ты помощник студента. Твоя задача — отфильтровать ХЭШТЕГИ.
    
    ВАЖНО: Хэштег может быть отправлен без дополнительного текста. В таком случае оценивай сам смысл слова в хэштеге.

    Критерии ВАЖНОСТИ (is_important = True):
    1. Теги предметов (#матан, #физика, #история) — ВАЖНЫ ВСЕГДА, даже без контекста (это значит, что сообщение относится к теме).
    2. Теги типов заданий (#дз, #лаба, #дедлайн, #экзамен, #расписание).
    3. Организационные теги (#сбор, #объявление, #важно).

    Критерии МУСОРА (is_important = False):
    1. Эмоциональные теги (#боль, #жиза, #лол, #кек).
    2. Бессмысленные теги, спам или личные метки, не относящиеся к учебе.
    3. Теги, которые ставят просто так (#привет, #чат).

    Поле 'about':
    - Если есть контекст (текст сообщения), опиши суть обсуждения.
    - Если контекста НЕТ (или он дублирует тег), просто напиши категорию. 
    ОГРАНИЧЕНИЕ: Максимум 10 слов.
    Пример: "Материалы по расписанию"
    """,

    "mention": """
    Ты помощник студента. Твоя задача — отфильтровать УПОМИНАНИЯ ЛЮДЕЙ (меншны).

    Критерии ВАЖНОСТИ:
    1. Когда человека зовут, чтобы дать конкретное задание или задать вопрос по учебе.
    2. Упоминания старосты или преподавателя по делу.
    3. Распределение ролей в групповых проектах ("@user ты делаешь презентацию").

    Критерии МУСОРА:
    1. "Голые" упоминания без текста (просто "@user") — считаем мусором, если это не выглядит как перекличка.
    2. Упоминания в шутках или флуде.
    3. Приветствия ("@user привет").

    Поле 'about': 
    - Напиши, кого и зачем позвали. 
    - Если контекста мало, попробуй угадать цель по тону, или напиши "Вызов пользователя".
    ОГРАНИЧЕНИЕ: Максимум 10 слов.
    Пример: "Вопрос к @ivanov по экзамену"
    """
}


async def analyze_items(
        items: List[Any],
        item_type: Literal["link", "doc", "task", "mention", "hashtag"]
) -> List[dict]:
    if not items:
        return []

    # 1. Формируем список для анализа
    input_lines = []
    for item in items:
        # Унификация полей (так как у Link поле url, у Doc поле document_name)
        main_content = ""
        if item_type == "link":
            main_content = item.url
        elif item_type == "doc":
            main_content = item.document_name
        elif item_type == "task":
            main_content = item.task_name
        elif item_type == "mention":
            main_content = item.mention
        elif item_type == "hashtag":
            main_content = item.hashtag

        input_lines.append(f"ID: {item.id} | Content: {main_content} | User Context: {item.context}")

    text_block = "\n".join(input_lines)

    # 2. Выбираем ПРАВИЛЬНЫЙ промпт
    system_prompt = PROMPTS.get(item_type, "Filter specific important items.")

    full_prompt = f"{system_prompt}\n\nList to analyze:\n{text_block}"

    try:
        # 3. Запрос
        result = await structured_llm.ainvoke(full_prompt)

        # 4. Мэппинг результатов
        verdict_map = {v.id: v for v in result.items}
        filtered = []

        for item in items:
            verdict = verdict_map.get(item.id)
            if verdict and verdict.is_important:
                filtered.append({
                    "original": item,
                    "about": verdict.about
                })
        return filtered

    except Exception as e:
        print(f"ML Error: {e}")
        return []
